#summary Reference Guide describing every feature of #summary Reference Guide describing every feature of SolidBase (in progress)

== Contents ==
 * [#ASSERT_EMPTY ASSERT EMPTY]
 * [#ASSERT_EXISTS ASSERT EXISTS]
 * [#IF_HISTORY IF HISTORY] (upgrade only)
 * [#IGNORE_SQL_ERROR IGNORE SQL ERROR]
 * [#IMPORT_CSV IMPORT CSV]
 * [#PRINT_SELECT PRINT SELECT]
 * [#SECTION SECTION]
 * [#SELECT_CONNECTION SELECT CONNECTION]
 * [#SET_DELIMITER SET DELIMITER]
 * [#SET_USER SET USER]
 * [#SKIP SKIP]
 * [#TRANSIENT TRANSIENT] (upgrade only)

----------------------------------------
== ASSERT EMPTY ==
Asserts that a given query does not return results.
=== Since ===
1.0
=== Syntax ===
{{{
ASSERT EMPTY MESSAGE "<error message>" <select statement>
}}}
=== Example ===
{{{
--* // To support an action that does not work when data is present in the table.
--* // For example adding a NOT NULL column.
ASSERT EMPTY MESSAGE "The TEMP_DATA table should not contain any data during the upgrade"
SELECT *
FROM TEMP_DATA;
}}}

----------------------------------------
== ASSERT EXISTS ==
Asserts that a given query returns results.
=== Since ===
1.0
=== Syntax ===
{{{
ASSERT EXISTS MESSAGE "<error message>" <select statement>
}}}
=== Example ===
{{{
--* // Switching from another change control tool to SolidBase:
--* // We need to check that the database has the correct version in the version tables of the other tool.
ASSERT EXISTS MESSAGE "The upgrade expects version 1.34 of the database"
SELECT *
FROM OLD_STYLE_VERSION_TABLE
WHERE CURRENT_VERSION = '1.34';
}}}

----------------------------------------
== IF HISTORY ==
(Upgrade only)

Conditional execution of commands depending on the historical upgrade path.
This is useful when the upgrade path contains branches.
In that case, the main upgrade path needs to sometimes be able to change its behaviour depending on
the branch path being followed or not.
The complete history is stored in the database.
=== Since ===
1.5.0
=== Syntax ===
{{{
--* IF HISTORY [NOT] CONTAINS <version>
--* /IF
}}}
=== Example ===
{{{
--* // If the upgrade history includes version 1.1.5 then the column has already been added to the table.
--* IF HISTORY NOT CONTAINS "1.1.5"
ALTER TABLE ATABLE ADD ACOLUMN INTEGER;
--* /IF
}}}

----------------------------------------
== IGNORE SQL ERROR ==
Enables ignoring of specific database errors.

Ignores can be nested. Ignores are reset at the beginning of each upgrade block.
=== Since ===
1.0
=== Syntax ===
{{{
--* IGNORE SQL ERROR <SQLState> [, <SQLState>, ...]
--* /IGNORE SQL ERROR
}}}
=== Example ===
{{{
--* IGNORE SQL ERROR S0001
DROP VIEW NONEXISTING_VIEW;
--* /IGNORE SQL ERROR
}}}

----------------------------------------
== IMPORT CSV ==
Fast import of inline CSV data. Uses JDBC batch updates for maximum insert rate.
=== Since ===
1.6.0
=== Syntax ===
{{{
IMPORT CSV
[ SEPARATED BY (TAB|<character>) ]
INTO <tablename> 
[ ( <columnlist> ) ]
[ VALUES ( <valuelist> ) ]
DATA
... csv data delimited with the current delimiter ...
}}}
=== Examples ===
{{{
--* // This import depends on the order of the columns in the table
IMPORT CSV INTO ATABLE DATA
1,2,3
4,5,6;

--* // This import explicitly specifies the columns, which is safer
IMPORT CSV INTO ATABLE ( COL1, COL2, COL3 ) DATA
1,2,3
4,5,6;

--* // Different separators
IMPORT CSV SEPARATED BY TAB INTO ATABLE DATA
1	2	3
4	5	6;
IMPORT CSV SEPARATED BY | INTO ATABLE DATA
1|2|3
4|5|6;

--* // Using double quotes you can prevent whitespace from being stripped around the values
--* // You need double quotes when commas are part of the values
--* // Double quotes in the values should be doubled
IMPORT CSV INTO ATABLE ( COL1, COL2, COL3 ) DATA
"  surrounding whitespace   ", 2, 3
"here is a comma, which is ok", 5, 6
"""Life is good"", he said", 5, 6;

--* // Values can be reordered, duplicated, ignored, transformed, and introduced
IMPORT CSV
INTO ATABLE ( ID, COL1, COL2, COL3 )
VALUES ( ASEQUENCE.NEXTVAL, TO_DATE( :2, 'YYYY-MM-DD' ), :1, :1 )
DATA
"  surrounding whitespace   ", "2001-01-01", 3
"here is a comma, which is ok", "2003-01-01", 6
"""Life is good"", he said", "2004-01-01", 6;
}}}

----------------------------------------
== PRINT SELECT ==
Prints the result of the select statement.
=== Since ===
1.6.0
=== Syntax ===
{{{
PRINT SELECT ... normal select statement ...;
}}}
=== Example ===
{{{
IMPORT CSV INTO ATABLE DATA
... csv data ...;
PRINT SELECT "Imported " || COUNT(*) || " records into ATABLE" FROM ATABLE;
}}}

----------------------------------------
== SECTION ==
Sets the next message to be displayed. The message will be displayed as soon as a command is executed.
=== Since ===
1.6.0
=== Syntax ===
{{{
--* SECTION "<message>"
}}}
=== Example ===
{{{
--* SECTION "Creating indexes"
}}}

----------------------------------------
== SELECT CONNECTION ==
Selects another connection/database.

Each upgrade block starts with the default user and the default connection.
=== Since ===
1.5.0
=== Syntax ===
{{{
--* SELECT CONNECTION <connectionname>
}}}
=== Example ===
{{{
--* SELECT CONNECTION QUEUES
}}}
=== See also ===
Configuring multiple connections (TODO)

----------------------------------------
== SET DELIMITER ==
Changes the current delimiter for commands. This a needed when stored procedures are part of the upgrade.
=== Since ===
1.6.0
=== Syntax ===
{{{
--* SET DELIMITER [ ISOLATED | TRAILING ] <delimiter1> [ OR [ ISOLATED |TRAILING ] <delimiter2> ]
}}}
=== Examples ===
{{{
--* // Creating a stored procedure
--* SET DELIMITER ISOLATED GO
CREATE PROCEDURE APROCEDURE IS
BEGIN
	... a lot of semicolons are found here ...
END; -- In Oracle you need this semicolon after the END
GO
--* SET DELIMITER TRAILING ;

--* // Other examples
--* SET DELIMITER ;;
--* SET DELIMITER ISOLATED GO OR TRAILING ;;
}}}

To set the default delimiter, add the following to the upgrade file definition:

=== Since ===
1.6.0
=== Syntax ===
{{{
--* DELIMITER IS [ ISOLATED | TRAILING ] <delimiter1> [ OR [ ISOLATED |TRAILING ] <delimiter2> ]
}}}
=== Example ===
{{{
--* DEFINITION
--*		DELIMITER IS ISOLATED GO
--*		...
--* /DEFINITION
}}}

----------------------------------------
== SET USER ==
Changes the current user.

Will ask for the password once.

Each upgrade block starts with the default user and the default connection.

Not supported when using the Ant task or Maven plugin, the secondary connections facility should be used instead when using Ant or Maven.
=== Since ===
1.0
=== Syntax ===
{{{
--* SET USER <username>
}}}
=== Example ===
{{{
--* SET USER OTHERUSER
}}}

----------------------------------------
== SKIP ==
Skips commands.
=== Since ===
1.6.2
=== Syntax ===
{{{
--* SKIP
--* /SKIP
}}}
=== Example ===
{{{
--* SKIP
-- In Oracle this is a command that you sometimes see in SQL files to 
-- prevent & from being recognized as a parameter to the SQL file.
-- It is a SQLPlus command, and should be skipped when executing this SQL file with SolidBase.
SET DEFINE OFF;
--* /SKIP
}}}

----------------------------------------
== TRANSIENT ==
(Upgrade only)

Marks commands as transient (not persisted).
During upgrade, persistent statements are counted (all commands that do not start with --`*`). This is needed to restart the upgrade after a failure.
After a restart, already executed persistent statements are skipped automatically.
Transient commands however, like the one in the example below, should not be counted and not be skipped after a restart.
=== Since ===
1.6.1
=== Syntax ===
{{{
--* TRANSIENT
--* /TRANSIENT
}}}
=== Example ===
{{{
--* TRANSIENT
ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD';
--* /TRANSIENT
}}}
